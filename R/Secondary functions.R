#!#############################################################################
#!
#!                       Secondary functions (internally used)                 
#!
#!#############################################################################

#! distributed lags
dlag <- function(x, lags = 1, na.action = na.pass)  #! ADD TIME INDEX
# x: vector of data to lag
# lags: vector of lags to apply
# na.action: action for the NAs generated by the lagging
{
    n <- length(x)
    L <- length(lags)
    maxlag <- max(lags)
    res <- matrix(NA, n, L)
    for (j in 1:L){
        lj <- lags[j]
        res[(lj+1):n,j] <- x[1:(n-lj)]
    }
    res <- do.call(na.action, list(res))
    return(res)
}

dlag_len <- function(x, lag, na.action = na.pass)
# x: vector of data to lag
# lag: maximum lag
# na.action: action for the NAs generated by the lagging
{
  lags <- 0:lag
  return(dlag(x, lags, na.action))
}


#! L2 loss function
L2 <- function(y, yhat, w){ 
    n <- length(y)
    if (missing(w)) w <- rep(1 / n, n)
    return(weighted.mean((y-yhat)^2, w))
}




#! Derivation by first differences
ppr.der <- function(x, z, gz, alpha){ #! TODO add pooling as in Friedman (1984) or litterature review for numeric derivation
    zord <- order(z)
    gzs <- gz[zord]
    xs <- x[zord,]
    dgzs <- (gzs[3:n] - gzs[1:(n-2)]) / ((xs[3:n,] - xs[1:(n-2),])%*%alpha)
    dgzs <- c(dgzs[1], dgzs, dgzs[n-2])
    dgz <- dgzs[rank(z)]
}

#! Different smoothers
#! Retirer alpha?
spline.smoother <- function(z, y, w, ...){
    sm.fit <- smooth.spline(z, y, w = w, ...)
    gz <- predict(sm.fit, z)$y
    dgz <- predict(sm.fit, z, deriv = 1)$y
    return(list(gz = gz, dgz = dgz))
}

super.smoother <- function(z, y, w, ...){
    gz <- supsmu(z, y, wt = w, ...)$y[rank(z)]
    dgz <- ppr.der(x = x, z = z, gz = gz, alpha = get("alpha", envir = parent.frame()))
    return(list(gz = gz, dgz = dgz))
}

scam.smoother <- function(z, y, w, const = "mpi", df = -1, ord = NA, lambda = NULL, ...){
    fit <- scam(y ~ s(z, bs = const, k = df, m = ord, sp = lambda), data = data.frame(y, z), weights = w, ...)
    gz <- predict(fit, data.frame(z = z), type = "response")
    dgz <- scam::derivative.scam(fit)
    return(list(gz = as.vector(gz), dgz = as.vector(dgz$d)))
}

###############################################################################
#
#                           Alpha
#
###############################################################################



#' Normalization of a vector of alphas
#'
#' Provides different ways to normalize a vector.
#'
#' @param alpha Numeric vector to normalize.
#' @param type Character indicating the type of normalization. List...
normalize <- function(alpha, type = "L2"){
  anorm <- switch(type,
    L2 = norm(alpha, "2"),
    L1 = norm(as.matrix(alpha), "1"),
    sum = sum(alpha),
    1
  )
  out <- if (anorm != 0) alpha / anorm else alpha
  attr(out, "norm") <- anorm
  return(out)
}


###############################################################################
#
#                                Smoothing
#
###############################################################################

#' Estimate ridge functions g
#'
#' Performs scatterplot smoothing to obtain ridge functions g.
#'
#' @param x A matrix or data frame giving indices (one per column).
#' @param y A numeric vector containing the output of the model.
#' @param w A numeric vector containing weights.
#' @param method A character value giving the method for smoothing.
#' @param shape A character vector indicating the type of smoothing for each
#'    index. Recycled if not the same length as \code{ncol(x)}. Can be one of
#'    the smoothers available in the \code{mgcv} package (see 
#'    code{\link[mgcv]{smooth.terms}}). Can also be one of the 
#'    shaped-constrained smoothers in \code{scam} (see 
#'    code{\link[scam]{shape.constrained.smooth.termss}}).
#'    Can also be "l" for linear.
#' @param ... Additional arguments to be passed to the method.
smoothing <- function(x, y, w, method = "gam", shape = "tp", ...)
{
  dots <- list(...)
  x <- as.data.frame(x)
  n <- length(y)
  p <- ncol(x)
  if (method == "gam" && 
    any(shape %in% c("mpi", "mpd", "cx", "cv", "micx", "micv", "mdcx", "mdcv")))
    method <- "scam"
  shape <- rep_len(shape, p)
  nonlin <- shape != "l"
  nlin <- sum(shape == "l")
  #--- SCAM
  if (method == "scam"){
    form.rhs <- colnames(x)
    form.rhs[nonlin] <- sprintf("s(%s, bs = '%s')", 
      form.rhs[nonlin], shape[nonlin])
    form <- sprintf("y ~ %s", paste(form.rhs, collapse = " + "))
    scam.pars <- c(list(formula = as.formula(form), 
      data = data.frame(y = y, x), weights = w), dots)
    gfit <- do.call(scam::scam, scam.pars)
    gx <- predict(gfit, type = "terms")
    namx <- colnames(x)
    namx[nonlin] <- sapply(gfit$smooth, "[[", "label")
    gx <- gx[,pmatch(namx, colnames(gx)), drop = FALSE]
    dmod <- lapply(which(nonlin), scam::derivative.scam, object = gfit)
    dgx <- matrix(NA, n, p)
    dgx[,nonlin] <- sapply(dmod, "[[", "d")
    if (nlin > 0) dgx[,!nonlin] <- 
      matrix(coef(gfit)[1:nlin + 1], nrow = n, ncol = nlin, byrow = TRUE)
    beta0 <- coef(gfit)[1]
  } else { if (method == "gam"){
    form.rhs <- colnames(x)
    form.rhs[nonlin] <- sprintf("s(%s, bs = '%s')", 
      form.rhs[nonlin], shape[nonlin])
    form <- sprintf("y ~ %s", paste(form.rhs, collapse = " + "))
    gam.pars <- c(list(formula = as.formula(form), 
      data = data.frame(y = y, x), weights = w), dots)
    gfit <- do.call(mgcv::gam, gam.pars)
    gx <- predict(gfit, type = "terms")
    namx <- colnames(x)
    namx[nonlin] <- sapply(gfit$smooth, "[[", "label")
    gx <- gx[,pmatch(namx, colnames(gx))]
    dmod <- gratia::fderiv(gfit, newdata = x)  #! github package gratia. May want to change this line if the package is not available on CRAN when the paper is published
    dgx <- matrix(NA, n, p)
    dgx[,nonlin] <- sapply(dmod$derivatives, "[[", "deriv")
    if (nlin > 0) dgx[,!nonlin] <- 
      matrix(coef(gfit)[1:nlin + 1], nrow = n, ncol = nlin, byrow = TRUE)
    beta0 <- coef(gfit)[1]
  } else { if(method == "scar"){
    scar.pars <- c(list(x = data.matrix(x), y = y, shape = shape, weights = w), 
      dots)
    gfit <- do.call(scar::scar, scar.pars)
    gx <- gfit$componentfit
    dgx <- mapply(function(x, gx) splinefun(x, gx)(x, deriv = 1), 
      as.data.frame(x), as.data.frame(gx))
    beta0 <- gfit$constant
  }}}
  return(list(intercept = beta0, gz = gx, dgz = dgx, fit = gfit))  
}
