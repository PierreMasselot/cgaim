#' Alpha control
#' 
#' Internal function setting up the control of alpha coefficients estimation
#'  Use this as a comprehensive list of allowed parameters for the 
#'  \code{alpha.control} argument in \code{\link{cgaim}}.
#'
#' @param Cmat Overall constraint matrix for alpha coefficients.
#'   Number of columns must match the total number of alpha coefficients. 
#'   Common constraints can be given in the formula through \code{\link{g}}.
#' @param alpha.start A vector or list of starting alpha values. If \code{NULL},
#'    staring values are generated internally.
#' @param init.type If \code{alpha.start = NULL}, the type of starting values
#'    to generate. If \code{init.type = "regression"} (the default), the
#'    starting values are generated by regressing the index design matrix on
#'    the response. If \code{init.type = "random"}, the starting values are
#'    generated randomly, ensuring they fall in the feasible region. In the
#'    latter case, it might be wise to estimate the model several times with
#'    different starting values to keep the best fit.
#' @param norm.type A character giving the type of normalization applied on
#'    each alpha_j vector for it to have norm 1. One of \code{"L2"} (the default)
#'    for classical euclidean norm, \code{"L1"} for absolute norm and 
#'    \code{"sum"} for the simple sum.
#' @param solver The quadratic programming solver to use. Either 
#'    \code{"osqp"} (the default) (see \code{\link[osqp:solve_osqp]{solve_osqp}}) 
#'    or \code{"quadprog"} (\code{\link[quadprog:solve.QP]{solve.QP}})
#' @param qp_pars A named list of parameters to be passed to the QP function.
#'    See help pages for the corresponding functions.
#'
#' @export
alpha.setup <- function(Cmat = NULL, alpha.start = NULL, 
  init.type = "regression", norm.type = "L2", solver = "osqp", 
  qp_pars = list())
{
  if (is.vector(Cmat)){
    Cmat <- t(as.matrix(Cmat))
  }
  if (!is.null(alpha.start)){
    alpha.start <- unlist(alpha.start)
  }
  init.type <- match.arg(init.type, c("regression", "random"))
  solver <- match.arg(solver, c("osqp", "quadprog")) 
  # OSQP
  # adaptive_rho = FALSE allows the algorithm to converge
  #   to a feasible solution.
  #   See (https://github.com/oxfordcontrol/osqp/issues/151)
  def_settings <- list(verbose = FALSE, adaptive_rho = FALSE,
    eps_abs = formals(osqp::osqpSettings)$eps_abs)
  qp_pars <- c(qp_pars, def_settings[!names(def_settings) %in% names(qp_pars)])
  return(list(Cmat = Cmat, alpha.start = alpha.start, init.type = init.type, 
    norm.type = norm.type, solver = solver, qp_pars = qp_pars)) 
}


alpha_init <- function(y, x, w, index, 
  init.type = c("regression", "random"), Cmat = NULL, 
  norm.type = "L2", ...)
{
  init.type <- match.arg(init.type)
  dots <- list(...)
  alpha <- switch(init.type,
    random = {
      pars <- dots[names(dots) %in% names(formals(limSolve::xsample))]
      pars$G <- Cmat
      pars$H <- rep(0, nrow(Cmat))
      res <- suppressWarnings(do.call(limSolve::xsample, pars))$X
      res[nrow(res),]
    },
    regression = {
      pars <- dots[names(dots) %in% names(formals(alpha_update))]
      pars <- within(pars, {
        y <- y; x <- x; w <- w; index <- index; Cmat <- Cmat
        dgz <- matrix(1, length(y), max(index))
        alpha <- rep(0, ncol(x))
        delta <- FALSE
      })
      do.call(alpha_update, pars)
    }
  )
  # Normalization
  alpha <- unlist(tapply(alpha, index, normalize, type = norm.type))
  return(alpha)
}



alpha_update <- function(y, x, w, index, dgz, alpha, 
  delta = TRUE, Cmat = NULL, solver, qp_pars)
{
  d <- ncol(x)
  lvec <- as.vector(table(index))
  # prepare predictors
  zerod <- apply(dgz, 2, function(x) all(x == 0))
  if (any(zerod)) dgz[,zerod] <- .Machine$double.eps
  dgz <- dgz[,index]
  Vmat <- x * dgz
  # prepare response
  if (!delta){ 
    y <- y + Vmat %*% alpha
  }
  if (!is.null(Cmat)){
    l <- if (delta) drop(-(Cmat %*% alpha)) else rep(0, nrow(Cmat))
    alpha.up <- update.QP(y, Vmat, w, Cmat, l, solver, qp_pars)    
  } else {
    alpha.up <- stats::coef(stats::lm(y ~ 0 + Vmat, weights = w))
    if (any(is.na(alpha.up))){ # For non-convergence cases
      ridge.apply <- MASS::lm.ridge(y ~ 0 + Vmat, weights = w, 
        lambda = seq(0,1,0.01))
      alpha.up <- stats::coef(ridge.apply)[which.min(ridge.apply$GCV),]
    }
  }
  return(alpha.up)
}


update.QP <- function(y, x, w, Cmat, low, solver, qp_pars)
{
  W <- diag(w)
  Dmat <- t(x) %*% W %*% x
  dvec <- 2 * t(y) %*% W %*% x
  low <- low + max(c(formals(osqp::osqpSettings)$eps_abs, qp_pars$eps_abs))
  sol <- switch(solver,
    osqp = osqp::solve_osqp(P = Dmat, q = -dvec, A = Cmat, 
      l = low, u = rep(Inf, nrow(Cmat)), pars = qp_pars)$x,
    quadprog = quadprog::solve.QP(Dmat, dvec, t(Cmat), bvec = low)$solution
  )
  return(sol)
}


normalize <- function(alpha, type = "L2"){
  anorm <- switch(type,
    L2 = norm(alpha, "2"),
    L1 = norm(as.matrix(alpha), "1"),
    sum = sum(alpha),
    1
  )
  if (!is.na(anorm) && anorm != 0) alpha <- alpha / anorm
  attr(alpha, "norm") <- anorm
  return(alpha)
}