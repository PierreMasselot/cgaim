#' Alpha control
#' 
#' Parameters for fine tuning of alpha coefficients estimation.
#'
#' @param Cmat Overall constraint matrix for alpha coefficients.
#'   Number of columns must match the total number of alpha coefficients. 
#'   Constraints on individual indices can also be conveniently specified
#'   through the \code{\link{g}} function in the formula.
#' @param bvec Vector containing boundary values for the constraints. If only
#'  Cmat is provided, the default is a vector of zeros.
#' @param alpha.start A vector or list of starting alpha values. If \code{NULL},
#'    starting values are generated internally.
#' @param init.type If \code{alpha.start = NULL}, the type of starting values
#'    to generate. If \code{init.type = "regression"} (the default), the
#'    starting values are generated by regressing the index design matrix on
#'    the response. If \code{init.type = "random"}, the starting values are
#'    generated randomly, ensuring they fall in the feasible region. In the
#'    latter case, it might be wise to estimate the model several times with
#'    different starting values to keep the best fit.
#' @param norm.type Character giving the type of normalization applied on
#'    each alpha_j vector for it to have norm 1. 
#'    See \code{\link[base:norm]{norm}}.
#' @param solver The quadratic programming solver to use. Implemented
#'  solvers are "quadprog" and "osqp" (see corresponding packages).
#' @param ctol Tolerance value to be added to \code{bvec} giving some margin
#'  on the constraints. Useful for cases in which rounding errors result
#'  in alphas slightly violating the constraints.
#' @param qp_pars A named list of parameters to be passed to the QP function.
#'    See help pages for the corresponding functions.
#'
#' @export
alpha.control <- function(Cmat = NULL, bvec = NULL, alpha.start = NULL,
  init.type = "regression", norm.type = "1", solver = "osqp", ctol = 1e-3, 
  qp_pars = list())
{
  pars <- as.list(match.call())[-1]
  defpars <- formals(alpha.control)
  pars <- c(pars, defpars[!names(defpars) %in% names(pars)])
  if (is.null(pars$bvec)) pars$bvec <- 0
  if (NROW(pars$Cmat) != NROW(pars$bvec)){
    pars$bvec <- rep_len(pars$bvec, NROW(pars$Cmat))
  }
  pars$init.type <- match.arg(init.type, c("regression", "random"))
  pars$solver <- match.arg(solver, c("quadprog", "osqp"))
  pars$qp_pars <- do.call(sprintf("def.%s", pars$solver), list(qp_pars))
  return(pars)
}

# Sets up alpha estimation
index.setup <- function(mf, alpha_control)
{
  # Initialize controls
  alpha_control <- do.call(alpha.control, alpha_control)
  # Extract index variables
  mt <- attr(mf, "terms")
  index_interp <- mf[attr(mt, "specials")$g]
  # Labels for smoothing step
  index_labels <- make.names(sapply(index_interp, attr, "label"), unique = T)
  # Extract response
  y <- stats::model.response(mf)
  attr(y, "varname") <- all.vars(mt)[1]
  # Extract weights
  w <- mf$`(weights)`
  if (is.null(w)) w <- rep(1, NROW(y))
  # Organizing variables in indices as a matrix with index positions   
  p <- length(index_interp)
  pvec <- sapply(index_interp, attr, "nterms")
  index <- rep(1:p, pvec)
  Xind <- do.call(cbind, index_interp)
  names(index) <- rep(index_labels, pvec)
  # Number of variables and indices
  ptot <- sum(sapply(index_interp, ncol))
  # Check Cmat
  if (!is.null(alpha_control$Cmat)){
    if (is.vector(alpha_control$Cmat)) alpha_control$Cmat <- 
        t(as.matrix(alpha_control$Cmat))
    if (ncol(alpha_control$Cmat) != ptot){
      stop("Number of columns in alpha_control$Cmat does not match
        the indices")
    }
  }
  # Add Cmat provided in index specific specifications
  alpha_control$Cmat <- rbind(alpha_control$Cmat, 
    as.matrix(Matrix::bdiag(lapply(index_interp, attr, "Cmat"))))
  # Add bvec
  alpha_control$bvec <- c(alpha_control$bvec, 
    unlist(lapply(index_interp, attr, "bvec"), use.names = F))
  # Check if there are any duplicates
  dups <- duplicated(alpha_control$Cmat)
  alpha_control$Cmat <- alpha_control$Cmat[!dups,,drop = F]
  alpha_control$bvec <- alpha_control$bvec[!dups]
  # Initialize alpha
  if (is.null(alpha_control$alpha.start)){
    init_pars <- alpha_control
    init_pars <- c(init_pars, list(y = y, x = Xind, w = w, index = index))
    alpha_control$alpha <- do.call(alpha_init, init_pars)
  } else {
    alpha_control$alpha <- unlist(alpha_control$alpha.start)
    if(length(alpha_control$alpha) != ptot){
      warning(paste0("alpha.start length is inconsistent with index matrix ", 
        "and is recycled"))
      alpha_control$alpha <- rep_len(alpha_control$alpha, ptot)
    }
  }
  alpha_control$alpha.start <- alpha_control$init.type <- NULL
  return(list(y = y, x = Xind, index = index, w = w,
    alpha_control = alpha_control)) 
}